/* Copyright Statement:
*
* (C) 2005-2017  MediaTek Inc. All rights reserved.
*
* This software/firmware and related documentation ("MediaTek Software") are
* protected under relevant copyright laws. The information contained herein
* is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
* Without the prior written permission of MediaTek and/or its licensors,
* any reproduction, modification, use or disclosure of MediaTek Software,
* and information contained herein, in whole or in part, shall be strictly prohibited.
* You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
* if you have agreed to and been bound by the applicable license agreement with
* MediaTek ("License Agreement") and been granted explicit permission to do so within
* the License Agreement ("Permitted User").  If you are not a Permitted User,
* please cease any access or use of MediaTek Software immediately.
* BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
* THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
* ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
* WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
* NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
* SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
* SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
* THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
* THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
* CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
* SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
* STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
* CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
* AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
* OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
* MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*/
/*
 **************************************************************************
 * File Description                                                      */
/** \file
 * Background Short Messages signals
 *
 *  Contains definitions of GSM SM signal structures (primitives or other
 *  events), generated by SM or received by SM from the foreground layer
 *  via the background layer shell.
 **************************************************************************/

#ifndef ABSM_SIG_H
#define ABSM_SIG_H

/***************************************************************************
 * Nested Include Files
 **************************************************************************/
#include <absm_typ.h>
#include <smrl_sig.h>
#include <ts_sig.h>
#include <alsi_sig.h>

#include <alsa_sig.h>

#if defined (ABSM_DEBUG)
#include <dmnvmcfg.h>
#endif

#include <uttime.h>

/** \defgroup SigApexSm  ABSM Signalling Interface
 * \ingroup NasApex
 * \ingroup Sig 
 * This section covers the APEX Short Message Service interface and the 
 * Background Layer Short Message Service procedure.
 * The Short Message Service is supported by a Background Layer procedure 
 * (ABSM) within the Application Layer task of the GSM handset. ABSM provides 
 * an interface between the Foreground Layer and the short message transport 
 * layer of the Protocol Stack in order to support the Short Message Service 
 * facilities required in GSM Phase 2 handsets.
 * 
 * Figure below illustrates the APEX Short Message Service interface.
 *
 * \image html ABSM_Interface.png
 * @{
 */

/***************************************************************************
 * Manifest Constants
 **************************************************************************/

/***************************************************************************
 * Typed Constants
 **************************************************************************/


/***************************************************************************
 * Type Definitions
 **************************************************************************/
/* New signal structures for storing SM route information.*/
/** Sends a request to read current SMS routing information.
 * The ApexSmReadRouteReq signal is sent from the Foreground Layer task 
 * to the ABSM task in order to request the SM route information that is 
 * stored in NVRAM. This signal has two parameters: the Foreground task ID 
 * (sent in order for the conformation signal to be sent to the correct 
 * application task), and the command reference. 
 */
typedef struct ApexSmReadRouteReqTag
{
    /** Requesting task ID (Task to which Cnf signal is sent). */
    TaskId     taskId; 
    /** Command reference */
    Int16      commandRef;
}
ApexSmReadRouteReq;

/** The ApexSmReadRouteCnf signal is sent from the ABSM task to 
 * the Foreground Layer task in response to an ApexSmReadRouteReq. 
 * This signal has four parameters: the ABSM task ID, the command reference, 
 * the read status, and the SM route information. If the read success status 
 * is TRUE the SM route information returned is valid, otherwise it is invalid. 
 */
typedef struct ApexSmReadRouteCnfTag
{
    /** Id of background task */
    TaskId             taskId;  
    /** Command reference */
    Int16              commandRef;
    /** Whether or not reading of route from NVRAM was successful*/
    Boolean            success; 
    /** Current setting of SMS preferred service */
    SmsRoute           smsRoute;       /* Uplink Gsms routing type */
}
ApexSmReadRouteCnf;

/** Sends a request to write SMS routing information. 
 * The ApexSmWriteRouteReq signal is sent from the Foreground Layer 
 * task to the ABSM task in order to request that the SM route, stored 
 * in NVRAM, be updated. 
 */
typedef struct ApexSmWriteRouteReqTag
{
   /** Requesting task ID (Task to which Cnf signal is sent). */
   TaskId     taskId;  
   /** Command reference */
   Int16      commandRef;
   /** The preferred SMS route to be written */
   SmsRoute   smsRoute;     /* Uplink Gsms routing type  */
}
ApexSmWriteRouteReq;

/** Confirmation of the success or failure of a request 
 * to write SMS routing information. 
 * The ApexSmWriteRouteCnf signal is sent from the ABSM task to the 
 * Foreground Layer task in response to an ApexSmWriteRouteReq.  
 *
 * If the write success status is TRUE, the preferred SM route was 
 * successfully written to NVRAM. If the write success status is FALSE 
 * then either the requested SM route was invalid or was not successfully 
 * written to NVRAM.
 */
typedef struct ApexSmWriteRouteCnfTag
{
   /** The sending task ID */
   TaskId            taskId;  
   /** Command reference copied from corresponding request. */
   Int16             commandRef;
   /** Whether or not the preferred SM route was successfully written to NVRAM. */
   Boolean           success;        
}
ApexSmWriteRouteCnf;

/** Indication to inform Forground Layer task that requested to send an SMS of the 
 * result of MO SMS Call Control activity. Only valid when MO SMS Call control is 
 * enabled. 
 */

typedef struct ApexSmStkInfoIndTag
{
  /** Sending task ID (TASK_BL_ID) */
  TaskId                taskId;
  /** the result of MO SMS Call control */
  SimatCcStatus         ccStatus;  
  /** if SIM has supplied information concerning the SMS Call Control*/
  Boolean               alphaIdPresent;
  /** text supplied from SIM concerning SMS Call Control */
  SimatAlphaIdentifier  alphaId;
}
ApexSmStkInfoInd;

/* NBNBNB PJA CHANGES
 *
 * Added Int8commandRef to all reqs and cnfs
 *  changed request status to type SmrequestStatus
 */

/** This signal sends an ready indication to the foreground layer. 
 * The ApexSmReadyInd signal indicates to the Foreground Layer whether 
 * the Short Message procedure is ready to receive further signals. 
 * It also informs the Foreground Layer of: <UL>
 * <LI> The number of unread messages on the SIM 
 * <LI> Whether or not there are more messages at the service centre which cannot be received as the SIM memory is full 
 * <LI> The number of SMS storage locations available on the SIM
 * <LI> The record number of the first free record. </UL>
 */
typedef struct ApexSmReadyIndTag
{
  /** The sending task ID (always TASK_BL_ID) */
  TaskId                taskId;
  /** Status of ABSM */
  SmRequestStatus       requestStatus;
  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if a message has been received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** The number of SMS storage locations on the SIM */
  Int8                  numberOfSmsRecords; /* FR9710-1480 */
  /** The record number of the first free record on the SIM */
  Int8                  firstFreeRecord;    /* FR9801-1889 */
  /** The number of SMSP storage locations. */
  Int8                  numberOfSmspRecords;
  /** Count of non-free SMSR records */
  Int8                  usedSmsrRecords;
  /** The number of SMSR storage locations on the SIM */
  Int8                  numberOfSmsrRecords;
  /** Current SMS Preferred Service (route)for instance GPRS only or CS_preferred.*/
  SmsRoute              smsRoute;  
}
ApexSmReadyInd;

/** The ApexSmStatusReq signal requests the current status of 
 * the SM procedure in the Background Layer.
 */
typedef struct ApexSmStatusReqTag
{
  /** Requesting task ID (Task to which Cnf signal is sent). */
  TaskId                taskId;
} ApexSmStatusReq;

/** The ApexSmStatusCnf reports the status of the SM procedure of the 
 * Background Layer and contains the same information as the ApexSmReadyInd.
 */
typedef struct ApexSmStatusCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Count actual number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** The number of SMS storage locations on the SIM */
  Int8                  numberOfSmsRecords;
  /** The record number of the first free record on the SIM */
  Int8                  firstFreeRecord;
  /** The number of SMSP storage locations. */
  Int8                  numberOfSmspRecords;
  /** Current SMS Preferred Service (route)for instance GPRS only or CS_preferred.*/
  SmsRoute              smsRoute;  
  /** The record number of the next SMS stored  */
  Int16                 smsStoreLoc;
  /** Count of read messages */
  Int8                  readRecords;
  /** Count of sent messages */
  Int8                  sentRecords;
  /** Count of unsent messages */
  Int8                  unsentRecords;
}
ApexSmStatusCnf;

/** Request to read an SMS from the SIM. 
 * The ApexSmReadReq signal requests the access of a message from the SIM. 
 * It is sent by the Foreground Layer. The Foreground Layer can select the type 
 * of message it requires:<UL>
 * <LI> first/next mobile-originated not sent
 * <LI> first/next mobile-originated sent
 * <LI> first/next mobile-terminated read
 * <LI> first/next mobile-terminated unread
 * <LI> Absolute
 * <LI> first/next mobile-originated (sent or not sent)
 * <LI> first/next mobile-terminated unread in preview mode (the status of the 
 * SMS record remains unread after the operation)
 * </UL>
 * If a next message is specified, the Background Layer uses the recordNumber to 
 * search. Whilst searching, the Background Layer will ignore all records which 
 * contain parts of a concatenated short message and only reports back when the 
 * first record is encountered.
 */
typedef struct ApexSmReadReqTag
{
  /** Requesting task ID (Task to which Cnf signal is sent). */
  TaskId                taskId;
  /** Command reference which is mirrored in the corresponding Cnf */
  Int16                 commandRef;
  /** Type of read required */
  SmsSimAccessType      readType;
  /** Record number to start from */
  Int8                  recordNumber;
}
ApexSmReadReq;

/** Request to read an SMS SR from the SIM. 
 * The ApexSmReadSmsrReq signal requests the access of a Status Report message from the SIM. 
 */
typedef struct ApexSmReadSmsrReqTag
{
  /** Requesting task ID (Task to which Cnf signal is sent). */
  TaskId                taskId;
  /** Command reference which is mirrored in the corresponding Cnf */
  Int16                 commandRef;
  /** Type of read required */
  SmsSimAccessType      readType;
  /** Record number to start from */
  Int8                  recordNumber;
}
ApexSmReadSmsrReq;

/** Confirmation of the success or failure of a request 
 * to read an SMS from the SIM.  
 * The ApexSmReadCnf signal holds the short message information obtained 
 * from a read request to the SIM. This signal results either from an 
 * ApexSmReadReq, or during initialisation. The flag countUnreadRec 
 * indicates that the ABSM is reading the SIM to establish the unreadCount 
 * and creating the smRecordStatus (during initialisation). 
 */
typedef struct ApexSmReadCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Validity of data in SIM 
\assoc PRESENT \ref scAddr */
  Boolean               smDataValid;
  /** Record number read */
  Int8                  recordNumber;
  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM is full */
  Boolean               memCapExceeded;
  /** Status of record */
  SimSmRecordStatus     smRecordStatus;
  /** Service centre address */
  SmsAddress            scAddr;
  /** Data type 
\assoc UNION \ref shortMessageTpdu */
  SimSmTpduType         type;
  /** Short message data */
  SimSmTpdu             shortMessageTpdu;
  /** TRUE if record contains a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The record number of the first concatenated SMS (if present).*/
  Int8                  concatSmsFirstRec;
  /** The previous concatenated SMS record number (if present). 
   * Equal to current record if this read contains the first record.
   */
  Int8                  concatSmsPrevRec;
  /** Next concatenated SMS record number (if present). 
   * Equal to current record if this read contains the last record.
   */
  Int8                  concatSmsNextRec;
  /** Time stamp information (Date sent / received) */ 
  RtcDate               smsDate;
  /** Time stamp information (Time sent / received) */ 
  RtcTime               smsTime; 
  /** TRUE if application port is present */
  Boolean               portPresent;
  /** Application source port number */
  Int16                 srcPort;
  /** Application destination port number */
  Int16                 dstPort;
  /** TRUE if it contains a WCMP message */
  Boolean               isWcmp;
  /** User interaction header element present */
  Boolean               userInteraction;
  /** Flag indicating the presence of Message Waiting Indication information 
\assoc PRESENT \ref mwiCombined */
  Boolean               mwiPresent;
  /** Decoded Message Waiting Indication Information */
  SmsMwiCombined        mwiCombined;
}
ApexSmReadCnf;

/** Confirmation of the success or failure of a request to read an SMS-SR from the SIM.  
 * The ApexSmReadCnf signal holds the SMS-SR information obtained 
 * from a read request to the SIM. This signal results from an ApexSmReadSmsrReq.
 */
typedef struct ApexSmReadSmsrCnfTag
{
    /** The sending task ID */
    TaskId                taskId;
    /** Command reference copied from the corresponding request */
    Int16                 commandRef;
    /** Success or failure of request */
    SmRequestStatus       requestStatus;
    /** Validity of data in SIM */
    Boolean               smsrDataValid;
    /** Record number read */
    Int8                  recordNumber;
    /** SMS Status Report */
    TsStatusReportInd     smStatusReport;

    /** Number of used records in SMS-SR file*/
    Int8                  usedSmsrRecord;
    /** Total number of Smsr record available*/
    Int8                  totalSmsrRecord;
}
ApexSmReadSmsrCnf;

/** The ApexSmDeliveryInd signal contains a terminating short 
 * message received from the service centre.
 */
typedef struct ApexSmDeliveryIndTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Originating address */
  SmsAddress            smeAddr;
  /** Service centre address */
  SmsAddress            scAddr;
  /** Whether or not reply path is present */
  Boolean               replyPath;
  /** Protocol information */
  SmsProtocolId         protocolId;
  /** Data coding information */
  SmsDataCoding         smsDataCodingScheme;
  /** More messages at service centre */
  Boolean               moreMsgsToSend;
  /** Parameter indicating if the SME has requested a status report*/
  Boolean               statusReportInd;
  /** Service centre time stamp */
  SmsTimeStamp          scTimeStamp;
  /** Data length 
\assoc ARRAY \ref shortMsgData */
  Int8                  shortMsgLen;
  /** Message data */
  Int8                  shortMsgData [SMS_MAX_MSG_LEN];
  /** Number unread messages on SIM */
  Int8                  unreadRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** Whether the record is part of a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The reference number from the user data header of this concatenated 
   * SMS message (if present)
   */
  Int16                 concatSmsRefNum;
  /** The number of this concatenated SMS message in the sequence (if present)*/
  Int8                  concatSmsSeqNum;
  /** The number of records in this concatenated SMS message (if present)*/
  Int8                  concatSmsLength;
  /** TRUE if the shortMsgData field contains user data headers
   * (Needed so FL tasks can decode EMS headers).
   */
  Boolean               userDataHeaderPresent;  
  /** TRUE if application port number valid */
  Boolean               portPresent;
  /** Source application port number */
  Int16                 srcPort;
  /** Destination application port number */
  Int16                 destPort;
  /** TRUE if it contains a WCMP message */
  Boolean               isWcmp;
  /** User interaction header element present */
  Boolean               userInteraction;
  /** Requested for SM in PDU mode */
  Int8                  shortMsgId;   
  /** TRUE if incoming SM was ciphered */
  Boolean               smsCipher;
  /** Flag indicating the presence of Message Waiting Indication information 
\assoc PRESENT \ref mwiCombined */
  Boolean               mwiPresent;
  /** Decoded Message Waiting Indication Information */
  SmsMwiCombined        mwiCombined;
}
ApexSmDeliveryInd;

/** The ApexSmDeliveryRsp signal sent from the CI task to the 
 * ABSM procedure to confirm correct reception of a new SMS 
 * messages or Status Reports, and it is used only when SMS 
 * service is set to 1 (refering to ApexSmProfileChangeReq and 
 * 3GPP 27.005 under CNMA AT command).
 */
typedef struct ApexSmDeliveryRspTag
{
  /** CI task */
  TaskId          taskId;
  /** Success or failure acknowledgement from terminal Equipment 
   * for the received message.
   */
  SmRequestStatus requestStatus;
  /** Used to identify the received SMS message. */
  Int8            shortMsgId;
}
ApexSmDeliveryRsp;

/** The ApexSmDeliveryWithReportRsp signal sent from the CI task to the 
 * ABSM procedure to confirm correct reception of a new SMS messages or 
 * Status Reports, and it is used only when SMS service is set to 1 
 * (refering to ApexSmProfileChangeReq and 3GPP 27.005 under CNMA AT command).
 * This signal also contains the optional delivery report.
 */
typedef struct ApexSmDeliveryWithReportRspTag
{
    /** CI task */
    TaskId                          taskId;
    /** Used to identify the received SMS message. */
    Int8                            shortMsgId;
    /** Indicates whether the SM was received correctly, if this field 
    * is equal to TRANSFER_OK
    */
    SmsStatusOfReport               statusOfReport;
    /** Indicating the reason for SMS DELIVER failure (field will be ignored) */
    TpFailureCause                  tpFailureCause;
    /** Indicates if smsProtocolId is present */
    Boolean                         smsProtocolIdPresent;
    /** Identifies the above layer protocol, if any */
    SmsProtocolId                   smsProtocolId;
    /** Indicates if SMS data coding is present */
    Boolean                         smsDataCodingSchemePresent;
    /** Data coding */
    SmsDataCoding                   smsDataCodingScheme;
    /** Network requires PID and DCS fields to be the same as in the
    * original TsDeliverInd, as per GSM 11.14, section 7.1.1
    */
    Int8                            rawDcsValue;
    /** Indicates the total number of valid data bytes */
    Int8                            userDataLength;
    /** May comprise just the short message itself or a Header in addition to the short */ 
    Int8                            userData[SMS_DELIVER_REPORT_MAX_USER_DATA_LENGTH];
    /** Parameter indicating that the TP UD field contains a Header */
    Boolean                         userDataHeaderPresent;
    /** whether the UDL + UD parameter is present*/
    Boolean                         udlPresent;
}
ApexSmDeliveryWithReportRsp;

/** This signal is used by the BL to indicate that a message should be 
 * stored on the ME. It will only be sent if abcfMeSmsStorageAvailable 
 * is set to TRUE and will be sent to the task identified by abcfMeSmsStorageTask 
 * (both in abcfg.c). The signal carries the received message and the 
 * receiving task should store the message if it can. The task should 
 * respond to the signal with an ApexSmStoreRsp signal using the command 
 * reference carried in the indication signal.
 */
typedef  struct ApexSmStoreIndTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference to use in the response */
  Int16                 commandRef;     /*Additional reference to hold ABSM transaction*/
  /** Originating address */
  SmsAddress            smeAddr;
  /** Service centre address */
  SmsAddress            scAddr;
  /** Whether or not reply path is present */
  Boolean               replyPath;
  /** Protocol information */
  SmsProtocolId         protocolId;
  /** Data coding information */
  SmsDataCoding         smsDataCodingScheme;
  /** More messages at service centre */
  Boolean               moreMsgsToSend;
  /** Service centre time stamp */
  SmsTimeStamp          scTimeStamp;
  /** Data length */
  Int8                  shortMsgLen;
  /** Message data */
  Int8                  shortMsgData [SMS_MAX_MSG_LEN];
  /** Number unread messages on SIM */
  Int8                  unreadRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** Whether the record is part of a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The reference number from the user data header of this 
   * concatenated SMS message (if present)
   */
  Int16                 concatSmsRefNum;
  /** The number of this concatenated SMS message in the sequence (if present)*/
  Int8                  concatSmsSeqNum;
  /** The number of records in this concatenated SMS message (if present)*/
  Int8                  concatSmsLength;
  /** TRUE if the shortMsgData field contains user data headers
   * (Needed so FL tasks can decode EMS headers)
   */
  Boolean               userDataHeaderPresent;  
  /** TRUE if application port number valid */
  Boolean               portPresent;
  /** Source application port number */
  Int16                 srcPort;
  /** Destination application port number */
  Int16                 destPort;
  /** TRUE if it contains a WCMP message */
  Boolean               isWcmp;
  /** User interaction header element present */
  Boolean               userInteraction;
  /** Requested for SM in PDU mode */
  Int8                  shortMsgId;             /* reqd for SM in PDU Mode */
  /** TRUE if incoming SM was ciphered */
  Boolean               smsCipher;
  /** Flag indicating the presence of Message Waiting Indication information 
\assoc PRESENT \ref mwiCombined */
  Boolean               mwiPresent;
  /** Decoded Message Waiting Indication Information */
  SmsMwiCombined        mwiCombined;
  /** Parameter indicating if the SME has requested a status report*/
  Boolean               statusReportInd;
}
ApexSmStoreInd;

/** This signal must be sent by the ME storage task to indicate whether 
 * the received message has been successfully stored or not. The task should 
 * use the command reference of the original indication signal in this response.
 * The storage task should respond promptly because the BL does not acknowledge 
 * the receipt of the message to the network until the ApexSmStoreRsp is received 
 * and there is an associated network time out. A requestStatus of SM_REQ_OK implies 
 * the message was successfully stored. SM_REQ_MEM_FULL means that ME 
 * storage is full. Any other value is assumed to mean an undefined failure.
 */
typedef struct ApexSmStoreRspTag
{
  /** ME storage task */
  TaskId          taskId;
  /** Command reference */
  Int16           commandRef;
  /** Store success or failure */
  SmRequestStatus requestStatus;
  /* The record number given to the SMS*/
  Int16           recordNumber;
}
ApexSmStoreRsp;

typedef struct ApexSmMeCapFullIndTag
{
  /** ME storage task */
  TaskId          taskId;
  /** Command reference */
  Int16           commandRef;
  /*TRUE indicate ME SMS capacity have no space*/
  Boolean         meSmsCapFull;
}
ApexSmMeCapFullInd;

/** The ApexSmMsgReceivedInd signal informs the Foreground Layer that 
 * a message has been received from the service centre and is stored 
 * on the SIM.
 */
typedef struct ApexSmMsgReceivedIndTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Record number on SIM */
  Int8                  recordNumber;
  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** Whether the record is part of a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The number of records in this concatenated SMS message (if present) */
  Int8                  concatSmsLength;
  /** Segment number of received message if part of a concatenated message.*/
  Int8                  concatSmsSeqNum;  
  /** Reference number of concatenated message */
  Int16                 concatSmsRefNum;  
  /** Number of segments of message currently stored */
  Int8                  concatStoredLength;  
  /** TRUE if application port number is valid */
  Boolean               portPresent;
  /** Source application port number */
  Int16                 srcPort;
  /** Destination application port number */
  Int16                 destPort;
  Boolean               isWcmp;
  /** Whether or not user interaction header element is present*/
  Boolean               userInteraction;
  /** TRUE if the last message segment has been received */
  Boolean               messageComplete;
  /* added for job101950 */
  /** Actual record number of a received concatenated SMS segment */
  Int8                  pduRecordNumber;
  /** Flag indicating the presence of Message Waiting Indication information 
\assoc PRESENT \ref mwiCombined */
  Boolean               mwiPresent;
  /** Decoded Message Waiting Indication Information */
  SmsMwiCombined        mwiCombined;
/*Add smsDataCodingScheme, protocolId & moreMsgsToSend in*/
  /** Identifies the coding scheme */
  SmsDataCoding         smsDataCodingScheme;
  /** Protocol identity */
  SmsProtocolId         protocolId;
  /** Whether or not there are more messages to send */
  Boolean               moreMsgsToSend;
  /** Location where the message has been stored*/
  AbsmMemAreaType       messageLoc;

    /*All the following fields are present to avoid MSMC to request for ABSM status*/

  /** The number of SMS storage locations on the SIM */
  Int8                  numberOfSmsRecords;
  /** Count of read messages */
  Int8                  readRecords;
  /** Count of sent messages */
  Int8                  sentRecords;
  /** Count of unsent messages */
  Int8                  unsentRecords;
}
ApexSmMsgReceivedInd;

/** The ApexSmSendReq signal is received from the Foreground Layer and requests 
 * the sending of a message to the service centre. 
 * The message data to be sent is given in the parameters of the signal. A message 
 * reference number to identify the message to the service centre must be allocated. 
 * The reference number of the last message sent is stored on the SIM and a copy of 
 * it is held in the local RAM. To allocate the number for this message therefore, 
 * the message reference copy in RAM is first updated and placed with the message 
 * data in a signal which is sent to the Protocol Stack. The SIM is then updated 
 * with the new message number. 
 * 
 * In the Phase 1 implementation it is possible to send the message and indicate 
 * to the Background Layer that the message is stored on the SIM (so that its 
 * status can be updated). This is not supported in the Phase 2 implementation: 
 * messages stored on the SIM must be sent with the ApexSmSendFromSimReq instead.
 *
 * For concatenated SMS messages the Foreground Layer will need to provide a unique 
 * reference number, length and sequence number. The Transport Protocol Data Unit 
 * (TPDU) data size should be no more than the maximum concatenated size less 6 
 * for user data header length.
 */
typedef struct ApexSmSendReqTag
{
  /** Requesting task ID (Task to which Cnf signal is sent). */
  TaskId                taskId;
  /** Command reference which is mirrored in cnf signal */
  Int16                 commandRef;
  /** Request for status report */
  Boolean               statusReportReq;
  /** Terminating address */
  SmsAddress            smeAddr;
  /** Service centre address */
  SmsAddress            scAddr;
   /** Whether or not reply path is present */
  Boolean               replyPath;
  /** Protocol identity */
  SmsProtocolId         protocolId;
  /** Coding and message class */
  SmsDataCoding         smsDataCodingScheme;
  /** Flag to indicate that the DCS should not be altered. 
   * Only set to TRUE when the SMS comes from the SIM. 
   * (SIM tookit SEND SM command).
   *
   * This will be used by STK application only.
   */
  Boolean               useRawDcs; 
  /** Raw DCS, as provided by the SIM (This will be used by 
   * STK application only).
   */
  Int8                  rawDcs;    
  /** Format of Validity Period (VP) */
  VpFormat              validityPeriodFormat;
  /** Validity period value */
  Int8                  validityPeriodAsValue;
  /** Validity period time */
  SmsTimeStamp          validityPeriodAsTime;
  /** Length of short message data 
\assoc ARRAY \ref shortMsgData */
  Int8                  shortMsgLen;
  /** Short message data */
  Int8                  shortMsgData [SMS_MAX_MSG_LEN];
  /*
   * 0007-7002 moved rejectDuplicates and userDataHeaderPresent
   * to outside of SIM_APP_TOOLKIT because they are not specific to SAT
   */
  /** Whether or not to reject duplicate messages */ 
  Boolean               rejectDuplicates;
  /** TRUE if the shortMsgData field contains user data headers */
  Boolean               userDataHeaderPresent;
  /** Whether the record is part of a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The reference number from the user data header of this 
   * concatenated SMS message (if present)
   */
  Int16                 concatSmsRefNum;
  /** The number of records in this concatenated SMS message (if present)*/
  Int8                  concatSmsLength;
  /** The number of this concatenated SMS message in the sequence (if present)*/
  Int8                  concatSmsSeqNum;
  /** To monitor FDN status */
  Boolean               doFdnCheck;  /*job100892*/
}
ApexSmSendReq;

/** Confirmation of the success or failure of a request 
 * to send a message to the service centre.   
 * The ApexSmSendCnf signal confirms the status to the Foreground Layer of a 
 * previous request to send a short message.
 */
typedef struct ApexSmSendCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Message reference of message sent */
  Int8                  messageRef;
  /* job132548: allow RP cause notification for all builds */
  /** Indicates if there is a Relay Protocol (RP) error */
  SmsStatusOfReport     statusOfReport;  
  /** RP error */
  RpCauseElement        rpCause;  
  /** Indicates if handset problem is present*/
  Boolean                meProblemPresent; 
  /** Indicates handset problem */
  SimatMeProblemAddInfo  meProblem;
  /** TRUE if sent message was ciphered */
  Boolean               smsCipher;
}
ApexSmSendCnf;

/** Request to send an SMS that is stored on the SIM. 
 * The ApexSmSendFromSimReq signal is received from the Foreground 
 * Layer and requests the sending of a message already stored on the 
 * SIM to the service centre.
 */
typedef struct ApexSmSendFromSimReqTag
{
  /** CI task */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number of message or the first concatenated SMS record on the SIM. */
  Int8                  recordNumber;
  /** if TRUE: send to the address specified in smeAddr if 
   * FALSE: use the stored SME address.
   
\assoc PRESENT \ref smeAddr */
  Boolean               smeAddrPresent;  /* FR9711-1656*/
  /** Terminating address */
  SmsAddress            smeAddr;
  /** if TRUE: use the SC address specified in scAddr if
   * FALSE: use the stored SME address.
   
\assoc PRESENT \ref scAddr */
  Boolean               scAddrPresent;   /* FR9711-1656*/
  /** Service centre address */
  SmsAddress            scAddr;
  /** To monitor FDN status */
  Boolean               doFdnCheck;
}
ApexSmSendFromSimReq;

/** The ApexSmSendFromSimCnf signal confirms the status to the 
 * Foreground Layer of a previous request to send a short message 
 * from the SIM.
 */
typedef struct ApexSmSendFromSimCnfTag
{
  /** The sending task ID */
  TaskId               taskId;
  /** Copied from the corresponding request */
  Int16                commandRef;
  /** Success or failure of request */
  SmRequestStatus      requestStatus;
  /* job132548: add RP cause notification */
  SmsStatusOfReport    statusOfReport;  /**< Indicates if RP error */
  /** RP error*/
  RpCauseElement       rpCause;        
  /** Number of messages sent */
  Int8                 numMessages;
  /** The message reference of each message sent */
  Int8                 messageRef[MAX_LENGTH_CONCATENATED_SMS];
}
ApexSmSendFromSimCnf;

/** Request to send a command to the Service Centre (SC). 
 * The ApexSmCommandReq signal allows the Foreground Layer to send an 
 * SMS command to the network, for example to request the status of a 
 * previously sent SMS message.
 */
typedef struct ApexSmCommandReqTag
{
  /** SIMAT_TASK_ID */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Protocol identity */
  SmsProtocolId         protocolId;
  /** Parameter specifying which operation is to be performed on a SM */
  SmsCommand            commandType;
  /** Message number to perform command on */
  Int8                  msgNum;
  /** Length of command data 
\assoc ARRAY \ref cmdData */
  Int8                  cmdDataLen;
  /** Command data */
  Int8                  cmdData [SMS_MAX_CMD_LEN];
  /** TRUE =>send a status report */
  Boolean               statusReportReq;
  /** Address associated with message being acted on (valid only 
   * for certain commands otherwise zero length)
   */
  SmsAddress            smeAddr;
  /** Service centre address */
  SmsAddress            scAddr;
}
ApexSmCommandReq;

/** The ApexSmCommandCnf  signal confirms that the previous 
 * ApexSmCommandReq has been correctly sent.
 */
typedef struct ApexSmCommandCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request */
  Int16                 commandRef;
  /** Status of command submission */
  SmRequestStatus       requestStatus;
  /** Message reference to which command referred */
  Int8                  messageRef;
}
ApexSmCommandCnf;

/** The ApexSmStatusReportInd signal contains a received status report
 */
typedef struct ApexSmStatusReportIndTag
{
    /** The sending task ID (TASK_BL_ID) */
    TaskId                taskId;
    /** SMSR Record number*/
    Int8                  smsrRecordNum;
    /** SMS message reference*/
    Int8                  messageRef;
    /** Location where the message has been stored*/
    AbsmMemAreaType       storingLoc;
    /** Whether or not there are more messages to send
    * (TRUE =>more reports will follow)
    */
    Boolean               moreMsgsToSend;
    /** SC address */
    SmsAddress            scAddr;
    /** Recipient address in report */
    SmsAddress            recipientAddr;
    /** Time when SC received the command */
    SmsTimeStamp          scTimeStamp;
    /** Time associated with the following status */
    SmsTimeStamp          receptionTime;
    /** Parameter identifying the status of the previously 
    * sent mobile originated short message
    */
    SmsStatus             smsStatus;
    /** Parameter indicating whether the previously submitted 
    * TPDU was an SMS-SUBMIT or an SMS COMMAND
    */
    SmsStatusReportQual   statusReportQual;
    /** TRUE if status report was ciphered */
    Boolean               smsCipher;
    /** Identifies the above layer protocol, if any  */
    SmsProtocolId         smsProtocolId;
    /** Indicates the scheme used for data coding */
    SmsDataCoding         smsDataCodingScheme;

    /** Number of used records in SMS-SR file*/
    Int8                  usedSmsrRecord;
    /** Total number of Smsr record available*/
    Int8                  totalSmsrRecord;
    /** The length of SM SR message */
    Int8                  shortMsgLen;
    /** Holds the SM SR message */
    Int8                  shortMsgData[SMS_MAX_MSG_LEN];
    /** Parameter indicating that the TP UD field contains a Header */
    Boolean               userDataHeaderPresent;
    /** Holds the TP-PI parameter */
    Int8                  piData[SMS_MAX_MSG_LEN];
    /** number of bytes used by TP-PI parameter*/
    Int8                  piLen;
    /** whether the protocol ID parameter is present*/
    Boolean               pidPresent ;
    /** whether the DCS parameter is present*/
    Boolean               dcsPresent;
    /** whether the UDL + UD parameter is present*/
    Boolean               udlPresent;
}
ApexSmStatusReportInd;

/** The ApexSmSmsrStoreIndTag signal contains a received status report 
 * that have to be stored in ME
 */
typedef struct ApexSmSmsrStoreIndTag
{
    /** The sending task ID (TASK_BL_ID) */
    TaskId                taskId;
    /** Command reference */
    Int16                 commandRef;
    /** SMS message reference*/
    Int8                  messageRef;
    /** True if the storage into ME is needed because the SIM is full*/
    Boolean               simFull;
    /** Whether or not there are more messages to send
    * (TRUE =>more reports will follow)
    */
    Boolean               moreMsgsToSend;
    /** SC address */
    SmsAddress            scAddr;
    /** Recipient address in report */
    SmsAddress            recipientAddr;
    /** Time when SC received the command */
    SmsTimeStamp          scTimeStamp;
    /** Time associated with the following status */
    SmsTimeStamp          receptionTime;
    /** Parameter identifying the status of the previously 
    * sent mobile originated short message
    */
    SmsStatus             smsStatus;
    /** Parameter indicating whether the previously submitted 
    * TPDU was an SMS-SUBMIT or an SMS COMMAND
    */
    SmsStatusReportQual   statusReportQual;
    /** TRUE if status report was ciphered */
    Boolean               smsCipher;
    /** Identifies the above layer protocol, if any  */
    SmsProtocolId         smsProtocolId;
    /** Indicates the scheme used for data coding */
    SmsDataCoding         smsDataCodingScheme;
    /** The length of SM SR message */
    Int8                  shortMsgLen;
    /** Holds the SM SR message */
    Int8                  shortMsgData[SMS_MAX_MSG_LEN];
    /** Parameter indicating that the TP UD field contains a Header */
    Boolean               userDataHeaderPresent;
    /** Holds the TP-PI parameter */
    Int8                  piData[SMS_MAX_SMSR_DATA_LEN];
    /** number of bytes used by TP-PI parameter*/
    Int8                  piLen;
    /** whether the protocol ID parameter is present*/
    Boolean               pidPresent ;
    /** whether the DCS parameter is present*/
    Boolean               dcsPresent;
    /** whether the UDL + UD parameter is present*/
    Boolean               udlPresent;
}
ApexSmSmsrStoreInd;

/** This signal must be sent by the ME storage task to indicate whether 
 * the received SMS-SR has been successfully stored or not. The task should 
 * use the command reference of the original indication signal in this response.
 * The storage task should respond promptly because the BL does not acknowledge 
 * the receipt of the SMS-SR to the network until the ApexSmStoreRsp is received 
 * and there is an associated network time out. A requestStatus of SM_REQ_OK implies 
 * the message was successfully stored. SM_REQ_MEM_FULL means that ME 
 * storage is full. Any other value is assumed to mean an undefined failure.
 */
typedef struct ApexSmSmsrStoreRspTag
{
    /** ME storage task */
    TaskId                  taskId;
    /** Command reference */
    Int16                   commandRef;
    /** Store success or failure */
    SmRequestStatus         requestStatus;
    /** SMSR Record number*/
    Int16                   smsrRecordNum;
}
ApexSmSmsrStoreRsp;

/** This signal is sent to warn foreground layer that a SMS-SR has been deleted
 */
typedef struct ApexSmSrDeletedIndTag
{
    TaskId                taskId;
    /** SMSR Record number */
    Int8                  smsrRecordNum;

    /** Number of used records in SMS-SR file*/
    Int8                  usedSmsrRecord;
    /** Total number of Smsr record available*/
    Int8                  totalSmsrRecord;
}
ApexSmSrDeletedInd;

/** The ApexSmStoreReq signal is received from the Foreground Layer 
 * and is a request to store a message on the SIM. The Background Layer 
 * will not allow non-empty records to be overwritten but existing 
 * messages can be stored in the same record.
 *
 * For the first segment of a concatenated SMS messages, if the writeType 
 * is SM_WRITE_FREE and record is 0, then the SMS is stored in free space 
 * on the SIM. Subsequent segments should use the SM_WRITE_FREE as writeType 
 * and record equal to the location of the first segment. If for the first
 * segment writeType is SM_WRITE_FREE and record is not 0 then the command 
 * refers to an existing message and the message is stored in the existing 
 * records which it occupies. 
 *
 * If the message requires more records than it previously occupied then 
 * free records are used to store the new parts of the message. The message 
 * is truncated if there are not enough free records. If the message requires 
 * less records than it previously occupied then the redundant records are 
 * deleted and marked as free. 
 *
 * If the record number is not 0, it must be the record number of the first 
 * record in the SMS sequence.
 */
typedef struct ApexSmStoreReqTag
{
  /** The sending task ID (TASK_BL_ID) */
  TaskId                taskId;  
  /** Comand reference */
  Int16                 commandRef;
  /** SM_WRITE_FREE, SM_RW_ABSOLUTE */
  SmsSimAccessType      writeType;
  /** SIM record number */
  Int8                  recordNumber;
  /** TPDU type 
\assoc UNION \ref tpdu */
  SimSmTpduType         type;
  /** TPDU */
  SimSmTpdu             tpdu;
  /** Whether the record is part of a concatenated SMS */
  Boolean               concatSmsPresent;
  /** The reference number from the user data header of 
  * this concatenated SMS message (if present)
  */
  Int16                 concatSmsRefNum;
  /** The number of records in this concatenated SMS message (if present)*/
  Int8                  concatSmsLength;
  /** The number of this concatenated SMS message in the sequence (if present)*/
  Int8                  concatSmsSeqNum;
  /** If a delivered message then TRUE implies it has been read
   * if a submit message then TRUE implies it has been sent
   */
  Boolean               isReadOrSent; 
  /** status for the SMS*/
  SimSmRecordStatus     smStatus;
}                                          
ApexSmStoreReq;

/** The ApexSmStoreCnf signal is sent to the Foreground Layer 
 * and confirms the success or failure of a previous request 
 * to write a record to the SIM.
 */
typedef struct ApexSmStoreCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request (ApexSmStoreReq) */
  Int16                 commandRef;
  /** Success or failure of the request */
  SmRequestStatus       requestStatus;
  /** Status of write */
  Boolean               shortMessageWritten;
  /** Record number written */
  Int8                  recordNumber;
  /** First free record number on SIM */
  Int8                  firstFreeRecord;    /* FR9801-1889 */
  /** If the store request was for a concatenated SMS, this is 
   * the number of records of the concatenated SMS which where 
   * or are going to be stored on the SIM. If this number is 
   * less than the corresponding number in the StoreReq then 
   * there was not enough room on the SIM to store the whole 
   * message and the message was truncated.
   */
  Int8                  concatSmsLength;
}
ApexSmStoreCnf;

/** Request to delete an SMS stored on the SIM. 
 * The ApexSmDeleteReq signal is a request from the Foreground 
 * Layer to delete a short message stored in the SIM.
 */
typedef struct ApexSmDeleteReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number to be deleted or first record of a concatenated SMS */
  Int8                  recordNumber;
}
ApexSmDeleteReq;

/** Confirmation of success or failure to delete a record from the
 * SIM.
 * The ApexSmDeleteCnf signal is sent to the Foreground Layer and 
 * confirms the success or failure of a previous request to delete 
 * a record from the SIM. A failure cause is reported if an attempt 
 * is made to delete a message which is not the first concatenated 
 * SMS.
 */
typedef struct ApexSmDeleteCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request (ApexSmDeleteReq) */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Status of deletion. */
  Boolean               shortMessageDeleted;
  /** Record deleted or first record of the deleted concatenated SMS */
  Int8                  recordNumber;
  /** Indicator to show valid data */
  Boolean               smDataValid;
  /** Service centre address */
  SmsAddress            scAddr;
  /** Data type 
\assoc UNION \ref shortMessageTpdu */
  SimSmTpduType         type;
  /** Message data */
  SimSmTpdu             shortMessageTpdu;
  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** TRUE if message received and not stored because SIM full */
  Boolean               memCapExceeded;
  /** First free record on SIM */
  Int8                  firstFreeRecord;    /* FR9801-1889 */
}
ApexSmDeleteCnf;

/** Request to delete an SMS SR stored on the SIM. 
 * The ApexSmDeleteSmsrReq signal is a request from the Foreground 
 * Layer to delete a Status Report message stored in the SIM.
 */
typedef struct ApexSmDeleteSmsrReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number to be deleted */
  Int8                  recordNumber;
}
ApexSmDeleteSmsrReq;

/** Confirmation of success or failure to delete a SR record from the
 * SIM.
 * The ApexSmDeleteSmsrCnf signal is sent to the Foreground Layer and 
 * confirms the success or failure of a previous request to delete 
 * a SR record from the SIM.
 */
typedef struct ApexSmDeleteSmsrCnfTag
{
    /** The sending task ID */
    TaskId                taskId;
    /** Copied from the corresponding request (ApexSmDeleteSmsrReq) */
    Int16                 commandRef;
    /** Success or failure of request */
    SmRequestStatus       requestStatus;
    /** Status of deletion. */
    Boolean               smsrDeleted;
    /** Record deleted */
    Int8                  recordNumber;
    /** Indicator to show valid data */
    Boolean               smsrDataValid;
    /** SMS Status Report */
    TsStatusReportInd     smStatusReport;

    /** Number of used records in SMS-SR file*/
    Int8                  usedSmsrRecord;
    /** Total number of Smsr record available*/
    Int8                  totalSmsrRecord;
}
ApexSmDeleteSmsrCnf;

/** The ApexSmWriteSmsrReq signal is a request from the Foreground 
 * Layer to write a Status Report message in the SIM.
 */
typedef struct ApexSmWriteSmsrReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number to be written to */
  Int8                  recordNumber;
}
ApexSmWriteSmsrReq;

/** Confirmation of success or failure to write a SR record into the
 * SIM.
 * The ApexSmWriteSmsrCnfTag signal is sent to the Foreground Layer and 
 * confirms the success or failure of a previous request to write 
 * a SR record into the SIM.
 */
typedef struct ApexSmWriteSmsrCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request (ApexSmWriteSmsrReq) */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Record wrote */
  Int8                  recordNumber;
  /** Indicator to show valid data */
  Boolean               smsrDataValid;
  /** SMS Status Report */
  TsStatusReportInd     smStatusReport;
}
ApexSmWriteSmsrCnf;

/** The ApexSmReadSmspReq signal reads the SMS parameters fields from 
 * a Phase 2 SIM.  These parameters are required to allow SMS messages 
 * to be transmitted from the mobile.
 */
typedef struct ApexSmReadSmspReqTag
{
  /** CI task Id */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** SMSP record to read */
  Int8                  recordNumber;
}
ApexSmReadSmspReq;

/** Confirmation whether writing of the SMS parameters field was 
 * successful or not. 
 * The ApexSmReadSmspCnf signal returns the SMS information requested 
 * by an ApexSmReadSmspReq.  The information includes (amongst other 
 * things) the service centre address, the validity period and the 
 * protocol ID.
 */
typedef struct ApexSmReadSmspCnfTag
{
  /** Background task Id */
  TaskId                taskId;
  /** Copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** TRUE => SMSP data is valid */
  Boolean               smspDataValid;
  /** SMSP record number read */
  Int8                  recordNumber;
  /** SMSP data read  */
  SimSmsParameters      smsp;
}
ApexSmReadSmspCnf;

/** This signal requests to modify SMS parameter values. 
 * The ApexSmWriteSmspReq signal requests that an SMS parameters record 
 * on a Phase 2 SIM be overwritten with new SMS parameters.
 */
typedef struct ApexSmWriteSmspReqTag
{
  /** CI task Id */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Method of writing SMSp data */
  SmsSimAccessType      writeType;
  /** Where data should be written on SIM */
  Int8                  recordNumber;
  /** SMSP data to be written */
  SimSmsParameters      smsp;
}
ApexSmWriteSmspReq;

/** The ApexSmWriteSmspCnf signal confirms whether writing of the 
 * SMS parameters field was successful or not.
 */
typedef struct ApexSmWriteSmspCnfTag
{ 
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Indicates free records on SIM */
  Boolean               noFreeRecords;
  /** SMSP record number written */
  Int8                  recordNumber;
}
ApexSmWriteSmspCnf;

/** This signal request to delet an SMS parameter entry. 
 * The ApexSmDeleteSmspReq signal allows an SMS parameters record 
 * to be deleted from a Phase 2 the SIM.
 */
typedef struct ApexSmDeleteSmspReqTag
{
  /** The sending task ID (CI task) */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number to delete */
  Int8                  recordNumber;
}
ApexSmDeleteSmspReq;

/** The ApexSmDeleteSmspCnf  signal confirms whether deleting of the 
 * SMS parameters field was successful or not.
 */
typedef struct ApexSmDeleteSmspCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** TRUE => smsp contains valid data */
  Boolean               smspDataValid;
  /** Record number deleted */
  Int8                  recordNumber;
}
ApexSmDeleteSmspCnf;

/** This signal gets a list of SMS parameters from the SIM. 
 * The ApexSmListSmspReq  signal requests a lists of the first <B>
 * n </B> SMS parameters from a Phase 2 SIM, starting from startRecord.
 */
typedef struct ApexSmListSmspReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Record number to start list from */
  Int8                  startRecord;
}
ApexSmListSmspReq;

/** Confirmation whether the request was successful or not. 
 * The ApexSmListSmspCnf signal returns up to <B> n </B> SMS
 * parameter records as a result of an ApexSmListSmspReq,  where
 * <B> n </B> is dictated by SIM_ALPHA_LIST_SIZE.
 */
typedef struct ApexSmListSmspCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Copied from the corresponding request */
  Int16                 commandRef;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Size of list fetched */
  Int8                  listSize;
  /** Array of SMSP records to which the alphaIds refer */
  Int8                  recordNumber [SIM_ALPHA_LIST_SIZE];
  /**Holds a list of Alpha IDs of the returned SMS parameter records */
  SimAlphaIdentifier    alphaId [SIM_ALPHA_LIST_SIZE];
}
ApexSmListSmspCnf;

/** The ApexSmFindSmspReq signal is used to request SMS parameters 
 * held in the Background Layer.
 */
typedef struct ApexSmFindSmspReqTag
{
  /** The sending task ID (SIMAT_TASK_ID)*/
  TaskId                    taskId;
  /** Command reference */
  Int16                     commandRef;
  /** Search mechanism */
  SmspFindMode              findMode;  
  /** Name of SMS parameters to search for */
  SimAlphaIdentifier        alphaId; 
  /** Index in Background Layer list */
  Int16                     index;    
  /** Where to get parameters from, SIM or NVRAM */
  SmspEntryType             entryType; 
}
ApexSmFindSmspReq;

/** The ApexSmFindSmspCnf signal is used to return the SMS parameters
 * requested by ApexSmFindSmspReq.
 */
typedef struct ApexSmFindSmspCnfTag
{
  /** The sending task ID (TASK_BL_ID)*/
  TaskId                    taskId;
  /** Copied from the corresponding request */
  Int16                     commandRef;
  /** Success or failure of search */
  SmRequestStatus           requestStatus;
  /** Source of returned parameters */
  SmspEntryFile             file;  
  /** The actual SIM record number */
  Int8                      recordNumber; 
  /** Set TRUE if valid data is returned */
  Boolean                   smspDataValid;
  /** The SMS parameters */
  SimSmsParameters          smsp;   
  /** Index in Background Layer list */
  Int16                     index;       
}
ApexSmFindSmspCnf;

/** This signal sends a record changed indication to
 * the foreground layers. 
 * The ApexSmRecordChangedInd signal is sent by the Background Layer 
 * to all Foreground Layers registered when any Foreground Layer adds 
 * any SMSs to the SIM or deletes any SMSs from the SIM.
 */
typedef struct ApexSmRecordChangedIndTag
{
    /** The sending task ID (TASK_BL_ID) */
    TaskId                taskId;
    /** Number of non-free records */
    Int8                  usedRecords;
    /** TRUE if memory capacity exceeded */
    Boolean               memCapExceeded;
    /** Number of unread messages */
    Int8                  unreadRecords;
    /** Number of unread records.
     ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
     ** its value will be equal to unreadCount.*/
    Int8                  unreadMemRecords;

    /*All the following fields are present for MSMC unsollicited indication*/

    /** The operation that has been done*/
    AbsmOperationType     operationType;
    /** SIM record number */
    Int8                  recordNumber;
    /** The number of SMS storage locations on the SIM */
    Int8                  numberOfSmsRecords;
    /** Count of read messages */
    Int8                  readRecords;
    /** Count of sent messages */
    Int8                  sentRecords;
    /** Count of unsent messages */
    Int8                  unsentRecords;
}
ApexSmRecordChangedInd;


/* job 103293*/
/** Request by a task to register as the consumer of the requested 
 * sms destination port number. 
 * The ApexSmRegisterPortReq signal can be used by any task to 
 * register as the consumer of SMSs with the supplied destination 
 * port number. This manages a dynamic list in addition to the 
 * static list that is specified in abcfg.c. The dynamic list 
 * is empty at power on and is not persistent after the ME has 
 * been power cycled. If successfully registered, any received 
 * SMS with the registered destination port will be forwarded
 * to the specified task with an ApexSmDeliveryInd without being 
 * saved on the SIM.
 *
 * \note Only one task can be registered for a specific destination 
 * port number. Subsequent attempts by a different task to register 
 * for the same destination port number will be rejected.
 */
typedef struct ApexSmRegisterPortReqTag
{
  /** Task to be registered */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Destination port number to register */
  Int16                 dstPort;
  /** Source port number */
  Int16                 srcPort;
  /** TRUE implies routing to be done on the srcPort value, 
   * FALSE means dstPort is used
   */
  Boolean               useSrcPort;  
}
ApexSmRegisterPortReq;

/** The ApexSmRegisterPortCnf signal confirms the result of the 
 * requested destination port number registration.
 */
typedef struct ApexSmRegisterPortCnfTag
{
  /** Command reference */
  Int16                 commandRef;
  /** Boolean reporting success/failure of the port registration request */
  Boolean               success;
}
ApexSmRegisterPortCnf;

/** Request by a task to deregister as the consumer of the requested sms destination
 * port number. 
 * The ApexSmDeregisterPortReq signal is used by a task to deregister 
 * a previously registered SMS destination port number. It is possible 
 * to deregister all previously registered destination ports for a 
 * specified task using this signal by setting the deRegisterAll flag to TRUE. 
 *
 * \note It is not possible to deregister a port that is in the static 
 * list specified in abcfg.c.
 */
typedef struct ApexSmDeregisterPortReqTag
{
  /** Task to be registered */
  TaskId                taskId;
  /** Command reference */
  Int16                 commandRef;
  /** Destination port number to register */
  Int16                 dstPort;
  /** Whether or not to deregister ALL entries */
  Boolean               deRegisterAll;
}
ApexSmDeregisterPortReq;

/** The ApexSmDeregisterPortCnf signal confirms whether or not 
 * the requested port deregistration was successful.
 */
typedef struct ApexSmDeregisterPortCnfTag
{
  /** Command reference */
  Int16                 commandRef;
  /** Boolean reporting success/failure of the port registration request */
  Boolean               success;
}
ApexSmDeregisterPortCnf;

/** This signal indicates the end of an SMS transaction. 
 * This signal informs all controlling tasks that the SMS 
 * transaction is complete and either was successful or 
 * has failed
 */
typedef struct ApexSmTransactionEndIndTag
{
  /** Always TASK_BL_ID */
  TaskId                taskId;
  /** TRUE implies transaction succeeded */
  Boolean               smsSuccessful;
  /** TRUE implies transaction is for mt sms */
  Boolean               incomingSms;
} ApexSmTransactionEndInd;

/** The ApexSmProfileChangeReq signal is sent from the CI task to 
 * the ABSM task in order to set SMS parameters defining New 
 * Message Indications to the Terminal Equipment. These parameters 
 * are defined in 3GPP 27.005 under +CNMI AT command.
 */
typedef struct ApexSmProfileChangedReqTag
{
  /** CI task */
  TaskId                taskId;
  /** Defines storing and displaying received SMS messages 
   * for all 4 [NUM_SMS_CLASSES_SUPPORTED] message classes.
   */
  Boolean               mtCnmiVal[NUM_SMS_CLASSES_SUPPORTED];
  /** Defines displaying received SMS Status Reports, supported 
   * values are 0,1 and 2.
   */
  Int8                  dsCnmiVal;
  /** In the case when message service is 1, acknowledgement for 
   * new received SMS messages and Status Reports is expected from 
   * Terminal Equipment.
   */
  Int8                  msgService;
  /** New received SMS messages have to be stored in the ME storage.
  *   This parameter is configured with AT+CPMS command.
  */
  Boolean               storeInMe;
}
ApexSmProfileChangedReq;

/* job116776 Introducing moreMessagesToSend functionality */
/** Configuring the PS to enable sending several
 * SMS messages without closing RR link in between. 
 * The ApexSmSendMoreReq signal is used to control the continuity 
 * of SMS relay protocol link. It is sent from the Foreground Layer 
 * task to the ABSM tprocedure to enable or disable SMS relay protocol 
 * link.  When enabled multiple SMS messages can be sent much faster 
 * as link is kept open. If the time between sending 2 SMS messages 
 * exceeds 5 seconds, the ME will close the link. This signal is 
 * introduced to support +CMMS AT command described in 3GPP 27.005.
 */
typedef struct ApexSmSendMoreReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Enble/disableSMS relay protocol link */
  Boolean               isEnabled;
}
ApexSmSendMoreReq;

/** The ApexSmStoreLocReq signal is sent from the CI task to 
 *  the ABSM task in order to set SMS stored location
 */
typedef struct ApexSmStoreLocReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Location of storage */
  Int16                 loc;
}
ApexSmStoreLocReq;

/** The ApexSmStoreLocCnf signal confirms the requested of setting
 *  SMS stored location.
 */
typedef struct ApexSmStoreLocCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
}
ApexSmStoreLocCnf;

/** The ApexSmSetLocStatusReq signal is sent from the CI task to 
 *  the ABSM task in order to set SMS stored location
 */
typedef struct ApexSmSetLocStatusReqTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Location to set */
  Int16                 loc;
  /** Status of location */
  SimSmRecordStatus      status;
}
ApexSmSetLocStatusReq;

/** The ApexSmSetLocStatusCnf signal confirms the requested of setting
 *  SMS location status.
 */
typedef struct ApexSmSetLocStatusCnfTag
{
  /** The sending task ID */
  TaskId                taskId;
  /** Success or failure of request */
  SmRequestStatus       requestStatus;
  /** Location to set */
  Int16                 loc;
  /** Status of location */
  SimSmRecordStatus     status;
}
ApexSmSetLocStatusCnf;


/** This indirection signal is sent when a SMS's status has been changed.
 */
typedef struct ApexSmStatusChangedIndTag
{
  /** Always TASK_BL_ID */
  TaskId                taskId;
  /** Record number read */
  Int8                  recordNumber;
  /** Status of record */
  SimSmRecordStatus     smRecordStatus;

  /*All the following fields are present to avoid MSMC to request for ABSM status*/

  /** Count of unread messages */
  Int8                  unreadRecords;
  /** Number of unread records.
   ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
   ** its value will be equal to unreadCount.*/
  Int8                  unreadMemRecords;
  /** Count of non-free records */
  Int8                  usedRecords;
  /** The number of SMS storage locations on the SIM */
  Int8                  numberOfSmsRecords;
  /** Count of read messages */
  Int8                  readRecords;
  /** Count of sent messages */
  Int8                  sentRecords;
  /** Count of unsent messages */
  Int8                  unsentRecords;
}ApexSmStatusChangedInd;

#if defined (ENABLE_L23_DEBUG)

typedef struct AbsmDebugMsgTag
{
    Int8          state;
/*    
    SmsProtocolId protocolId;
    SmsAddress    scAddr;
    SmsAddress    smeAddr;
    Int8          msgLength;
    Int16         concatRef;
    Int8          msgRef;
*/
    Int8          recNumber;
    Int8          seqNumber;
    SimSmTpduType type;         /*job 104228*/
}AbsmDebugMsg;

#define MAX_SM_DEBUG_NUM 30

typedef struct AbsmDebugIndTag
{
   /** The number of SMS storage locations on the SIM */
   Int8              numberOfSmsRecords;
   /** Indicates free records on SIM */
   Int8              freeRecordCount;
   /** Count of unread messages */
/* Int8              unreadCount;*/
   /** Number of unread records.
    ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
    ** its value will be equal to unreadCount.*/
/* Int8                  unreadMemRecords;*/
   /** The number allocated for pending received messages
    * (These are messages that we have received, reported 
    * we can store but have not yet stored it).
    */
/* Int8              recordsAllocated;*/
   /** SMS information */
/* Boolean           smInfo [MAX_OUTWARD_MSG_ID];*/
   /* used by SMS when Phase 1 SIM */
/* Int8              localMsgRef;*/
   /** True if local memory capacity is full */
/* Boolean           localMemCapFull;*/
   /** Number of SMS paramter records */
/* Int8              numberOfSmspRecords;*/
   /** Points to the stored message data associated with a given record */
   Int32             absmStoredMsg_p;
   /** Points to the free stored message */
   Int32             absmFreeMsg_p;
   /** Time stamp information (Time sent / received) */ 
/* SmsTimeStampData  timeStampData;*/
   /** Current setting of SMS preferred service */
/* SmsRoute          smsRoute;*/
   /** This has to be defined at the end of the signal
    * as size is now dynamic 
    */

   SimSmRecordStatus smRecordStatus[MAX_SM_DEBUG_NUM];

   AbsmDebugMsg absmStoredSm[MAX_SM_DEBUG_NUM];
}AbsmDebugInd;
#endif
#if defined (ABSM_DEBUG)
/** Sent as a response to ApexSmDebugReq */
typedef struct ApexSmDebugCnfTag
{
   /** The state of ABSM */
   AbsmState         state;
   /** The profile */
   AbsmProfile       profile;
   /** The number of SMS storage locations on the SIM 
\assoc VAR_ARRAY \ref smRecordStatus */
   Int8              numberOfSmsRecords;
   /** Indicates free records on SIM */
   Int8              freeRecordCount;
   /** Count of unread messages */
   Int8              unreadCount;
   /** Number of unread records.
    ** If modem doesn't handle concat SMS (see abcfSmHandleConcatSms),
    ** its value will be equal to unreadCount.*/
   Int8                  unreadMemRecords;
   /** The number allocated for pending received messages
    * (These are messages that we have received, reported 
    * we can store but have not yet stored it).
    */
   Int8              recordsAllocated;
   /** SMS information */
   Boolean           smInfo [MAX_OUTWARD_MSG_ID];
   /* used by SMS when Phase 1 SIM */
   Int8              localMsgRef;
   /** True if local memory capacity is full */
   Boolean           localMemCapFull;
   /** Number of SMS paramter records */
   Int8              numberOfSmspRecords;
   /** Points to the stored message data associated with a given record */
   Int32             absmStoredMsg_p;
   /** Points to the free stored message */
   Int32             absmFreeMsg_p;
   /** Time stamp information (Time sent / received) */ 
   SmsTimeStampData  timeStampData;
   /** Current setting of SMS preferred service */
   SmsRoute          smsRoute;
   /** This has to be defined at the end of the signal
    * as size is now dynamic 
    */
   SimSmRecordStatus smRecordStatus [MAX_SMS_RECORD];
}
ApexSmDebugCnf;

/** Debug signal */
typedef struct ApexSmDebugIndTag
{
  /** Whether or not free msg cache */
  Boolean       isFree;
  /** ABSM  state */
  Int8          state;
  SmsProtocolId protocolId;
  /** SC address */
  SmsAddress    scAddr;
   /** Originating address */
  SmsAddress    smeAddr;
  /** Number of segments in message */
  Int8          msgLength;
  /** Ref number for this concat message */
  Int16         concatRef;
  /** Record number of the message */
  Int8          recNumber;
  /** Sequence number of the message */
  Int8          seqNumber;
  /** Pointing to next message */
  Int32         nextMsg_p;
  /** Pointing to next segment */
  Int32         nextSeg_p;
  /** Pointing to previous segment */
  Int32         prevSeg_p;
}
ApexSmDebugInd;
#endif


/***************************************************************************
 *  Macros
 **************************************************************************/


/***************************************************************************
 *  Function Prototypes
 **************************************************************************/
/** @} */ /* End of SigApexSm group */
#endif

/* END OF FILE */
